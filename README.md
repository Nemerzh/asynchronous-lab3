# Паралельне виконання завдань за допомогою Executor Service, Thread Pool та Fork/Join Framework
### Варіант 15
## Опис завдання

У цьому проекті реалізовано дві програми, що використовують паралельне виконання для вирішення наступних завдань:

1. **Пошук елемента в двовимірному масиві**, значення якого співпадає з сумою його індексів. Кількість елементів масиву, початкові та кінцеві значення задає користувач. Масив генерується випадковим чином.
2. **Пошук зображень у директорії**. Користувач вибирає директорію, і програма знаходить всі зображення та відкриває останнє.

Для вирішення завдань використано **Executor Service**, **Thread Pool** та **Fork/Join Framework**. У програмі реалізовано два підходи паралельного виконання: **Work Stealing** і **Work Dealing**.

## Опис підходів

### Підхід 1: **Work Stealing**
У цьому підході кожен потік починає виконувати частину роботи. Якщо потік завершує свою частину роботи, він може «вкрасти» частину роботи у іншого потоку, що дозволяє ефективно використовувати ресурси.

### Підхід 2: **Work Dealing**
У цьому підході завдання розбивається на рівні частини, і кожен потік виконує свою частину. Потоки не можуть взаємодіяти між собою, що може бути менш ефективним при нерівномірному розподілі роботи.

## Реалізація та замір часу

### 1. Пошук елемента в двовимірному масиві

У цій програмі програма генерує двовимірний масив з випадковими значеннями та шукає елемент, значення якого дорівнює сумі його індексів. Час виконання програми заміряється для обох підходів — Work Stealing та Work Dealing.

Для цієї задачі підход через Work Stealing є кращим оскільки він дозволяє виконувати пошук швидше, за рахунок своєї здатності ефективно розподіляти робоче навантаження. 

### 2. Пошук зображень у директорії

Програма проходить по всіх файлах в директорії, яку вибирає користувач, і знаходить зображення. Вона виводить кількість знайдених файлів і відкриває останнє зображення.

Я обрав підхід Fork/Join Framework із використанням механізму Work Stealing, оскільки він ідеально підходить для ефективної обробки великих обсягів даних. Цей підхід працює за принципом поділу завдань на дрібніші підзадачі, що виконуються паралельно, і при цьому забезпечує динамічний перерозподіл навантаження між потоками. Завдяки цьому система автоматично використовує всі доступні ресурси максимально ефективно, скорочуючи час виконання.